---
author: Steve McConnell
title: Code Complete
tags:
    - programming
    - design
    - testing
    - OOP
---

# Code Complete

## Проектирование

Проектирование - разработка схемы преобразования спецификации в готовое приложение. Процесс, связывающий требования с программированием. Процесс проектирования неряшлив, т.к. совершается много ошибок.
Связано с определением компромиссов и приоритетов. Эвристический процесс, позволяющий принять решение разными способами. Проектирование должно сводить сложность проекта к минимуму. Управление сложностью - важная часть разработки ПО. Должно поддерживать простоту сопровождения, расширяемость, малое сопряжение между частями программы, портируемость, соответствие стандартам. Проектирование подсистем и их взаимодействие должно подчиняться четким правилам.
Компоненты проектирования:
- объекты реального мира
  . объекты и их атрибуты
  . действия объекта, и действия над объектом
  . открытый интерфейс объекта
- согласованные абстракции на уровне интерфейсов(дверной ручки, двери, дома)
- инкапсуляция реализации
- наследование
- сокрытие информации(источники изменений, сложные части)
- области вероятных изменений
  . бизнес-правила
  . зависимости от оборудования
  . ввод-вывод
  . нестандартные возможности языка
  . переменные статуса
  . размеры структур данных
- поддержка слабого сопряжения
- использования шаблонов проектирования
- максимальная связность в проектировании
- иерархии
- контракты классов
- сферы ответственности
- выбор времени связывания
- диаграммы
- поддержка модульности
Методики проектирования
- использование итерации(выбор лучшей из нескольких)
- восходящий и нисходящий подходы
- прототипирование
- совместное проектирование
- определение достаточности детальности проекта(очевидна реализация проекта)
- регистрация процесса
  . включение документации в код
  . wiki
  . электронная переписка
  . схемы и диаграммы
  . карточки

## Совместное конструирование 

Парное программирование:
- необходимы стандарты кодирования
- не подходит для реализации простых фрагментов
- регулярно менять состав пар и задачи
- учитывать особенности пар
- назначение лидера группы
Формальные инспекции:
- создание контрольных списков с указанием областей, в которых были проблемы
- посвящение инспекции обнаружению, а не исправлению дефектов
- целесообразность использования сценариев
- отдельная роль каждому участнику
- процедура инспекции: - планирование, обзор - подготовка - отчет - исправление дефектов - контроль Анализ, чтение кода

## Этапы создания классов и методов

Этапы создания класса:
 - Создание общей структуры класса(функции, секреты, интерфейс)
 - Конструирование всех методов
 - Оценка и тестирование всего класса
Этапы создания метода:
 - Проектирование
 - Проверка структуры
 - Кодирование
 - Тестирование

## Тестирование

Блочное тестирование - тестирование класса, метода отдельно от прочих частей системы. Тестирование компонента - тестирование класса, пакета или другого элемента системы, выполняемое в изоляции от остальных частей системы. Интеграционное тестирование - совместное выполнение нескольких компонентов системы. Регрессивное тестирование - повторное выполнение тестов, направленное на обнаружение дефектов в программе, прошедшей этот набор тестов. Тестирование системы - тестирование в окончательной конфигурации (безопасность, производительность, синхронизация).
Целью тестирования является нахождение ошибок, чем больше ошибок находит тест, тем он успешнее. Отсутствие ошибок может указывать на безупречность программы или на неполноту тестов. Чистые тесты - тестирование на предмет того, работает ли. Грязные тесты - тесты на нарушение работы.
Структурированное базисное тестирование - тестирование каждого оператора хотя бы раз.
Тестирование, основанное на потоках данных.
Анализ граничных условий.
Классы плохих и хороших данных.
Инструменты тестирования: леса(scaffolding), инструменты сравнения файлов, генераторы тестовых данных, мониторы покрытия кода тестами, регистраторы данных, отладчики, инструменты возмущения состояния системы.
Требования к тестированию:
 - каждому ли требованию(класс или метод) соответствует отдельный тест
 - каждая ли строка кода протестирована хотя бы одним тестом
 - каждый ли путь "определение - использование" протестирован
 - проверен ли код на отсутствие путей "определение - определение|выход|уничтожение"
 - протестированы ли все граничные условия
 - протестирован ли код на предмет неверных типов данных
 - протестирован ли код на минимальные, средние и максимальные конфигурации

## Рефакторинг

На уровне данных:
 - замена магических чисел на именованные константы
 - замена неудачного имени переменной
 - замена выражения на вызов метода
 - введение промежуточной переменной
 - использование локальных переменных вместо параметров
 - преобразование элементарного типа данных в класс
 - преобразование набора кодов в класс
 - преобразование массива в класс
На уровне отдельных операторов:
 - вынесение сложного логического выражения в функцию
 - возврат из метода сразу после получения ответа
 - замена на полиморфный метод
На уровне отдельных методов:
 - преобразование большого метода в класс
 - замена сложного алгоритма на простой
 - добавление|удаление параметра
 - объединение похожих методов путем параметризации
 - разделение метода на несколько, в зависимости от параметров
Реализация классов:
 - замена виртуальных методов на инициализацию данных
 - изменение положения в иерархии наследования
 - перемещение специализированного кода в подкласс
 - разделение класса на несколько
 - удаление класса-посредника
 - инкапсуляция открытой переменной
 - сокрытие методов
------------------------------------------
Стратегии рефакторинга:
 - выполнять при создании новых методов, классов
 - выполнять при исправлении дефектов
 - выполнять рефакторинг сложных и подверженных ошибкам модулей
 - определять интерфейс между чистым и грязным кодом

## Разработка архитектуры

Архитектура - высокоуровневая часть проекта, каркас. Проект высокого уровня. Архитектура определяет концептуальную целостность системы. Включает в себя общее описание системы. Включает подтверждения, что были рассмотрены альтернативные варианты. Определяет основные компоненты программы, их ответственность. Определяет основные классы, их взаимодействие, иерархию... Описывает виды данных, форматы. GUI, модульность. Определяет подход к безопасности, производительности, масштабируемости. Интернационализация, ввод-вывод. Определяет обработку ошибок, отказоустойчивость системы. Описывает стратегию изменений. Архитектура должна отражать все требования, исключая ненужные элементы.
Разработка архитектуры:
- все ли требования отражены
- мера проработки, целостность
- независимость проекта от платформы и языка
- мотивы принятия всех основных решений
- общая организация программы
- определение основных компонентов программы
- описание важных классов
- описание организации данных, БД
- описание важных бизнес-правил
- стратегия проектирования GUI
- ввод-вывод
- оценки степени использования потоков, соединений с БД, сетью...
- защищенность архитектуры
- требования к объему и быстродействию классов, подсистем
- масштабируемость, взаимодействие с другими системами
- локализация
- ошибки, отказы
- подтверждение технической реализации всех частей системы
- избыточная функциональность, повторное использование кода

## Псевдокод

Неформальная нотация на естественном языке, описывающая работу алгоритма, метода, класса, программы. Принципы:
 - применять формулировки, в точности описывающие отдельные действия
 - избегать синтаксических элементов языков программирования
 - писать на уровне намерений, описывать назначение, а не реализацию
 - детализация до того момента, когда код написать проще
Этапы проектирования с использованием псевдокода:
 - проверка предварительных условий
 - определить задачу метода
 - название метода
 - определить, как тестировать
 - продумать обработку ошибок
 - исследовать библиотечные возможности
 - исследовать алгоритмы и типы данных
 - написать псевдокод, несколько версий, выбрать лучшую
-----------------------------------------
 - написать на языке программирования первый и последний операторы
 - закомментировать псевдокод
 - продолжить преобразование псевдокода в реальный код
 - тестирование, исправление неточностей
-----------------------------------------
 - проверка интерфейса метода, входные/выходные данные
 - проверка качества конструкции, сопряжение
 - проверка переменных, логики
 - проверка форматирования, документирования, лишних комментариев

## Проектирование методов

Причины создания: снижение сложности, формирование промежуточной абстракции, предотвращение дублирования кода, поддержка наследования, сокрытие очередности действий, сокрытие операций над указателями, улучшение портируемости, упрощение сложных булевых проверок, повышение быстродействия.
 - Функциональная связность - лучший вид связности(cohesion), при которой метод обладает удачным именем и выполняет единственную конкретную задачу(sin, getcustomername, erasefile).
 - Последовательная связность - метод содержить операции, выполняющиеся в определенном порядке, использующие данные предыдущих этапов.
 - Коммуникационная связность - операции метода используют одни и те же данные и не связаны между собой иным способом.
 - Временная связность - операции объединены в метод на основании выполнения в один интервал времени(startup, shutdown).
 - Процедурная связность(плохая) - операции выполняются в определенном порядке.
 - Логическая связность(плохая) - выбор операции осуществляется на основе передаваемого флага.
-----------------------------------------
Имя метода:
 - описывать, что выполняет метод
 - избегать невыразительных и неоднозначных глаголов
 - не использовать для дифференциации имен методов исключительно номера
 - не ограничивать длину методов
 - использовать описание возвращаемого значения
 - использовать выразительный глагол, дополняя его объектом(printdocument, checkorderinfo).
 - использовать антонимы(open/close, up/down)
 - определять конвенции именования
Стараться не включать в метод более 200 строк.
Параметры метода:
 - в порядке "входные - изменяемые - выходные" значения
 - если несколько методов используют похожие параметры, передавать их в согласованном порядке
 - передавать переменные статуса или кода ошибки последними
 - не использовать параметры в качестве рабочих переменных
 - документировать выраженные в интерфейсе предположения о параметрах
 - ограничивать число параметров - 7
Функция - метод, возвращающий значение, процедура значений не возвращает. Если основная цель метода возврат значения, указанного в имени функции, использовать функцию, иначе процедуру.
Макросы нужно использовать только в крайнем случае.

## Проектирование классов

Класс - абстрактный тип данных. Причины создания:
- моделирование объектов реального мира
- моделирование абстрактных объектов
- снижение и изоляция сложности
- сокрытие деталей реализации
- ограничение влияния изменений
- ограничение области использования данных
- создание центральных точек управления
- повторное использование кода
Абстракция:
- присвоить классу удачное имя и сформулировать главную цель
- выражать в интерфейсе согласованный уровень абстракции
- полный набор сервисов класса
- предоставлять методы вместе с противоположными
- не нарушать целостность интерфейса
- убирать семантику из интерфейсов
- разделять разную информацию в разные классы
Инкапсуляция:
- минимальная доступность членов класса
- не делать предположений о клиентах класса
- скрытие деталей реализации от других классов
Наследование:
- моделирование отношения "является"
- Лисков правило
- избегать переопределения непереопределяемых методов
- не использовать много уровней иерархии наследования
- закрыть все члены базового класса
Вопросы реализации:
- ценить легкость чтения кода выше удобства написания
- избегать жесткого сопряжения
- инициализировать все данные-члены в конструкторе
- проектировать класс для полного копирования

## Порядок создания приложения

Выработка требований
Разработка архитектуры(высокоуровневое проектирование)
Детальное проектирование
Кодирование и отладка
Тестирование(блочное и интеграционное)
Интеграция системы
Тестирование системы
Корректирующее сопровождение

## Подготовка к конструированию

- порядок написания частей программы
- требования к именованию программных элементов, оформлению комментариев..
- методики кодирования
- определение стадии развития технологий
- работа в группе
- гарантии качества
- выбор языка, платформ, редактора, системы управления версиями

## Отладка

Процесс определения и устранения причин ошибок. Важно понимать, как работает программа и суть проблемы.
Правильная отладка:
 - сбор данных при помощи повторяющихся экспериментов
 - формулировка гипотезы
 - экспериментальное подтверждение|опровержение гипотезы
 - исправление дефекта
 - тестирование
Для успешной отладки нужно:
 - детализируйте тесты, приводящие к ошибке
 - unit tests
 - воспроизведите ошибку несколькими способами
 - сократите подозрительную область кода
 - с подозрением относитесь к классам и методам, ранее содержащим дефекты
 - проверьте код, недавно измененный
 - инкрементальная интеграция
 - отдохните от проблемы
 - установите сроки быстрой отладки

## Оптимизация производительности

Не всегда производительность программы достигается через оптимизацию кода. Быстродействие программы в большей степени зависят от архитектуры, проектирования. Сначала нужно завершить работу над программой, а затем начинать оптимизировать. Важнейшее условие максимизации быстродействия кода - количественная оценка. Как правило, основная часть времени выполнения программы приходится на небольшую часть кода.
Логика:
 - прекращение проверки после получения ответа
 - упорядочение тестов по частоте
 - откладывание на потом, кэширование
 - замена сложных проверок на таблицы(с++)
Циклы:
 - размыкание(цикл внутри условия, не наоборот)
 - объединение циклов
 - минимизация объема работы
 - вложение более ресурсоемкого цикла в менее
 - снижение стоимости операций(например, умножения на сложение)
Изменение типов данных:
 - использование целых чисел вместо floating
 - использование минимально-мерных массивов
 - минимизация обращений к массивам
Выражения:
 - алгебраические тождества
 - инициализация во время компиляции
 - учитывать недостатки системных методов
 - использование констант корректного типа
 - предварительное вычисление результата

## Метафоры

Метафора - эвристический подход, она больше похожа на прожектор, чем на дорожную карту. Они помогают понять процесс разработки ПО, сравнивая его с другими процессами. Метафоры: литературная, фермерская, жемчужина, строительная.

## Личность и мастерство

Высочайший уровень интеллекта - не главное условие для человека, желающего стать хорошим программистом. Методики эффективного программирования призваны снизить нагрузку на мозг:
 - декомпозиция системы
 - обзоры, тестирование, инспекции - способы компенсации человеческих оплошностей
 - ограничение объема методов
 - абстракция и использование конвенций
Важная черта - любопытство. Нужно изучить процесс разработки, экспериментировать, читать о решении проблем, анализировать и планировать перед действиями, изучать успешные проекты, общаться с единомышленниками.
Профессиональная честность:
 - отказ от притязаний на роль эксперта
 - признание своих ошибок
 - стремление разобраться в ошибках
 - предоставление реальных отчетов и оценок о проекте
Лень, как отсутствие спешки и лишних движений. Нужно вырабатывать хорошие привычки с самого начала.
Путь к мастерству:
 Борьба со сложностью
 Анализ процесса разработки
 Написание программы в первую очередь для людей
 Программирование с использованием языка, а не на языке
 Соглашения для концентрации внимания
 Разделение программы на уровни абстракций
 Использовать итеративный принцип разработки

## Качество ПО

Идентифицировали ли вы специфические характеристики качества
Провели ли вы различие между внешними и внутренними характеристиками качества
Как будут одни характеристики влиять на другие
Использует ли проект несколько методик обнаружения ошибок
Составлен ли план контроля качества
Чем можно определить повышение/понижение качества

## Интеграция

Стратегии инкрементной интеграции.
1. Нисходящая - сначала создаются классы, находящиеся на вершине иерархии, а те, что внизу, последними.
2. Восходящая - сначала интегрируются классы, находящиеся в низу иерархии.
3. Сэндвич - объединяются верхний уровень с нижним, а средний уровень напоследок.
4. Риск-ориентированная - в первую очередь реализуются самые трудные классы.
5. Функционально-ориентированная - работа идет по группам классов.
6. Т-образная - создается и интегрируется вертикальный срез системы, потом интегрируется горизонтальный срез.
Применяются ежедневные сборки и smoke тесты.

## Защитное программирование

Необходимо проверять входные данные:
 - данные из внешних источников
 - данные входных параметров
 - определение обработки неправильных данных
Использование утверждений(assertions):
 - попадание в определенный интервал
 - открытие/закрытие файла/потока, когда метод начинает/заканчивает выполняться
 - только чтение/запись/чтение и запись
 - значение не изменяется
 - указатель not null
 - размер массива
Принципы использования:
 - ожидаемые события и события, которые никогда не должны происходить
 - не помещать выполняемый код в утверждение
 - для документирования и проверки предусловий и постусловий
Способы обработки ошибок:
 - вернуть нейтральное значение
 - заменить следующим корректным блоком данных
 - вернуть тот же результат, что и в прошлый раз
 - подставить ближайшее допустимое значение
 - записать в журнал
 - вернуть код ошибки
 - вызвать обработчик ошибок
 - показать сообщение об ошибке
 - обработать локально
 - прекратить выполнение
Исключения:
 - для оповещения других частей программы об ошибках, которые нельзя игнорировать
 - для действительно исключительных ситуаций
 - избегать генерировать в конструкторах и деструкторах
 - помнить об абстракции
 - не использовать пустые блоки
 - централизованный вывод информации об исключениях
Нужно создавать "баррикады" для изоляции проверок. Во время разработки нужно настроить среду на получение как можно большего количества информации, журналов, но отключать в production.
Код в production:
 - оставить код, проверяющий существенные ошибки, и удалить, проверяющий незначительные
 - удалить код, приводящий к прекращению работы
 - оставить код, аккуратно завершающий
 - дружелюбность сообщений об ошибках
 - журналирование

## Выработка требований

Первое предварительное условие - ясное формулирование проблемы, которую нужно решить.Необходима формулировка на языке, понятном заказчику. Требования помогают свести к минимуму изменения системы после начала разработки. Желательно замораживать хотя бы на какое-то время требования. Нужно задавать процедуру контроля изменений требований.
Требования:
- способы ввода-вывода, источники, точность, диапазон...
- форматы вывода для отчетов, web...
- внешние апп и прогр интерфейсы
- задачи пользователя и все данные
- время реакции операций
- временные параметры
- защищенность системы
- минимальные требования(память и прочее)
- аспекты удобства сопровождения системы
- требования определения успеха/неудачи
- корректны ли требования(понятны, нет конфликтов)
- равновесие между компромиссными требованиями
- детальность требований
- тестирование требований
- возможные изменения требований
- полнота
